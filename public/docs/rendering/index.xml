<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Renderer on Codigrowa Docs</title>
    <link>https://codigrowa-docs.local/docs/rendering/</link>
    <description>Recent content in Renderer on Codigrowa Docs</description>
    <generator>Hugo</generator>
    <language>ja-jp</language>
    <atom:link href="https://codigrowa-docs.local/docs/rendering/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>GameCanvas / Renderer</title>
      <link>https://codigrowa-docs.local/docs/rendering/game-canvas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://codigrowa-docs.local/docs/rendering/game-canvas/</guid>
      <description>&lt;p&gt;&lt;code&gt;components/game-canvas.tsx&lt;/code&gt; は Game からのスナップショットを &lt;code&gt;@shopify/react-native-skia&lt;/code&gt; で描画するデモ実装です。エンジンの状態を UI に届ける際のベストプラクティスをまとめます。&lt;/p&gt;&#xA;&lt;h2 id=&#34;初期化フロー&#34;&gt;初期化フロー&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9d%e6%9c%9f%e5%8c%96%e3%83%95%e3%83%ad%e3%83%bc&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;startGame({ reset: true })&lt;/code&gt; を &lt;code&gt;useEffect&lt;/code&gt; で 1 度だけ呼び、GameLoop を開始。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;LinearMover&lt;/code&gt; のような Entity をインスタンス化して &lt;code&gt;game.addEntity()&lt;/code&gt; で登録。&lt;/li&gt;&#xA;&lt;li&gt;クリーンアップ時に &lt;code&gt;game.removeEntity(entity.id)&lt;/code&gt; を忘れない。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;レンダリング購読&#34;&gt;レンダリング購読&lt;a class=&#34;anchor&#34; href=&#34;#%e3%83%ac%e3%83%b3%e3%83%80%e3%83%aa%e3%83%b3%e3%82%b0%e8%b3%bc%e8%aa%ad&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;useEffect&lt;/span&gt;(() &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsubscribe&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;game&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onRender&lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;payload&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;setRenderPayload&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;payload&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  });&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsubscribe&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}, [&lt;span style=&#34;color:#a6e22e&#34;&gt;game&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;setRenderPayload&lt;/span&gt;]);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Zustand ストアの &lt;code&gt;entities&lt;/code&gt; を &lt;code&gt;Canvas&lt;/code&gt; に流し込むことで、UI 層は Game の内部構造に触れずに描画を完了できます。&lt;code&gt;LinearMoverSnapshot&lt;/code&gt; のように型ガードを挟めば、Canvas 上で扱うデータを限定できます。&lt;/p&gt;&#xA;&lt;h2 id=&#34;scheduler-を使った-hud&#34;&gt;Scheduler を使った HUD&lt;a class=&#34;anchor&#34; href=&#34;#scheduler-%e3%82%92%e4%bd%bf%e3%81%a3%e3%81%9f-hud&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;GameCanvas&lt;/code&gt; では &lt;code&gt;game.schedule()&lt;/code&gt; と &lt;code&gt;game.wait()&lt;/code&gt; を使い、定期ログと遅延ログを生成しています。&lt;code&gt;setFunctionLogs&lt;/code&gt; で最新 4 件だけ表示する仕組みは、Scheduler の動作確認に最適です。&lt;/p&gt;&#xA;&lt;h2 id=&#34;skia-との結合ポイント&#34;&gt;Skia との結合ポイント&lt;a class=&#34;anchor&#34; href=&#34;#skia-%e3%81%a8%e3%81%ae%e7%b5%90%e5%90%88%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Canvas&lt;/code&gt; 内では &lt;code&gt;entities&lt;/code&gt; のスナップショットをループして &lt;code&gt;Rect&lt;/code&gt; を描画。&lt;/li&gt;&#xA;&lt;li&gt;描画に必要な情報は &lt;code&gt;getSnapshot()&lt;/code&gt; の戻り値へ追加する。例: &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, &lt;code&gt;color&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;UI スレッドから World を直接触らず、描画で使う値はすべてスナップショットから取得する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;応用-別-renderer-への差し替え&#34;&gt;応用: 別 Renderer への差し替え&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bf%9c%e7%94%a8-%e5%88%a5-renderer-%e3%81%b8%e3%81%ae%e5%b7%ae%e3%81%97%e6%9b%bf%e3%81%88&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;同じ &lt;code&gt;Game.onRender()&lt;/code&gt; を WebGL や Three.js など別のレンダラへ接続しても問題ありません。&lt;code&gt;Game&lt;/code&gt; はレンダラ非依存なので、&lt;strong&gt;1 つの Game インスタンスを複数 Renderer が購読する&lt;/strong&gt; 構成も可能です（HUD + Canvas など）。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
