<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ランタイム on Codigrowa Docs</title>
    <link>https://codigrowa-docs.local/docs/runtime/</link>
    <description>Recent content in ランタイム on Codigrowa Docs</description>
    <generator>Hugo</generator>
    <language>ja-jp</language>
    <atom:link href="https://codigrowa-docs.local/docs/runtime/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>アーキテクチャ概観</title>
      <link>https://codigrowa-docs.local/docs/runtime/architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://codigrowa-docs.local/docs/runtime/architecture/</guid>
      <description>&lt;p&gt;Codigrowa のゲームエンジンは &lt;strong&gt;GameLoop → Scheduler → World → Entity → Renderer&lt;/strong&gt; という鎖で構成されています。Expo（React Native）上では &lt;code&gt;requestAnimationFrame&lt;/code&gt; を起点に時間が進み、React 側のコンポーネントは &lt;code&gt;Game.onRender()&lt;/code&gt; から受け取るスナップショットだけで描画を完結させます。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;useGameLoop (engine/hooks/useGameLoop.ts)&#xA;        │&#xA;        ▼&#xA;┌──────────────┐&#xA;│ Game         │  ← ランタイム中枢&#xA;│  • Scheduler │  ← 関数単位 tick&#xA;│  • World     │  ← Entity 単位 tick&#xA;└──────────────┘&#xA;        │&#xA;        ▼&#xA;Canvas Renderer (components/game-canvas.tsx)&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;データフロー&#34;&gt;データフロー&lt;a class=&#34;anchor&#34; href=&#34;#%e3%83%87%e3%83%bc%e3%82%bf%e3%83%95%e3%83%ad%e3%83%bc&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;useGameLoop&lt;/code&gt; が &lt;code&gt;requestAnimationFrame&lt;/code&gt; から &lt;code&gt;dt&lt;/code&gt;（秒）を算出し &lt;code&gt;Game.update(dt)&lt;/code&gt; を連続呼び出し。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Game.update&lt;/code&gt; はまず &lt;code&gt;Scheduler.update(dt)&lt;/code&gt; を処理し、待機中のコールバックを実行。&lt;/li&gt;&#xA;&lt;li&gt;続いて &lt;code&gt;World.process(dt)&lt;/code&gt; が全 &lt;code&gt;Entity&lt;/code&gt; の &lt;code&gt;process()&lt;/code&gt; を tick に合わせて回す。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Game.notifyRender()&lt;/code&gt; が World からのスナップショットをまとめ、&lt;code&gt;onRender&lt;/code&gt; 購読者（HUD や Skia Canvas）へ配布。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;描画層は &lt;code&gt;GameRenderPayload&lt;/code&gt; を受け取るだけで済むため、World/Entity の内部状態を UI から直接 mutate しません。これにより、レンダリングとロジックの責務分離とデバッグ容易性を両立しています。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Game クラス</title>
      <link>https://codigrowa-docs.local/docs/runtime/game/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://codigrowa-docs.local/docs/runtime/game/</guid>
      <description>&lt;p&gt;&lt;code&gt;engine/Game.ts&lt;/code&gt; はランタイムの司令塔です。World と Scheduler を束ね、1 tick ごとに状態更新と描画用スナップショット生成を行います。&lt;/p&gt;&#xA;&lt;h2 id=&#34;ライフサイクル-api&#34;&gt;ライフサイクル API&lt;a class=&#34;anchor&#34; href=&#34;#%e3%83%a9%e3%82%a4%e3%83%95%e3%82%b5%e3%82%a4%e3%82%af%e3%83%ab-api&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;メソッド&lt;/th&gt;&#xA;          &lt;th&gt;用途&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;start({ reset?: boolean })&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;GameLoop 起動。&lt;code&gt;reset&lt;/code&gt; で &lt;code&gt;elapsed&lt;/code&gt; / &lt;code&gt;tick&lt;/code&gt; を初期化し即スナップショット配布。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;pause()&lt;/code&gt; / &lt;code&gt;resume()&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;update()&lt;/code&gt; の実行を一時停止／再開。Zustand ストアから UI でトグル。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;stop()&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;ループ停止 + Scheduler タスク破棄。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;update(dt: number)&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Scheduler.update(dt)&lt;/code&gt; → &lt;code&gt;World.process(dt)&lt;/code&gt; → &lt;code&gt;notifyRender()&lt;/code&gt; の順で実行。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;&lt;code&gt;useGameLoop&lt;/code&gt; から渡される &lt;code&gt;dt&lt;/code&gt;（秒）だけを頼りに Game は決定的に進行します。React 側で &lt;code&gt;Game&lt;/code&gt; や &lt;code&gt;World&lt;/code&gt; を直接触る場合は、状態破壊を避けるためなるべく API 経由（&lt;code&gt;addEntity&lt;/code&gt;, &lt;code&gt;wait&lt;/code&gt; など）で操作してください。&lt;/p&gt;&#xA;&lt;h2 id=&#34;world--scheduler-依存差し替え&#34;&gt;World / Scheduler 依存差し替え&lt;a class=&#34;anchor&#34; href=&#34;#world--scheduler-%e4%be%9d%e5%ad%98%e5%b7%ae%e3%81%97%e6%9b%bf%e3%81%88&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;コンストラクタでは &lt;code&gt;new Game({ world, scheduler })&lt;/code&gt; としてテスト用のモックを注入できます。既存インスタンスを入れ替える場合は &lt;code&gt;setWorld()&lt;/code&gt; / &lt;code&gt;setScheduler()&lt;/code&gt; を利用します。&lt;/p&gt;</description>
    </item>
    <item>
      <title>World &amp; Entity</title>
      <link>https://codigrowa-docs.local/docs/runtime/world-entity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://codigrowa-docs.local/docs/runtime/world-entity/</guid>
      <description>&lt;p&gt;&lt;code&gt;engine/World.ts&lt;/code&gt; と &lt;code&gt;engine/entities/Entity.ts&lt;/code&gt; はエンジンの心臓部です。World が Entity を束ね、Entity は tickRate ごとに &lt;code&gt;_process()&lt;/code&gt; を実行します。&lt;/p&gt;&#xA;&lt;h2 id=&#34;world-の責務&#34;&gt;World の責務&lt;a class=&#34;anchor&#34; href=&#34;#world-%e3%81%ae%e8%b2%ac%e5%8b%99&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;addEntity(entity)&lt;/code&gt; / &lt;code&gt;removeEntity(id)&lt;/code&gt; / &lt;code&gt;clear()&lt;/code&gt; で登録を管理。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;process(dt)&lt;/code&gt; で全 Entity の &lt;code&gt;process(dt)&lt;/code&gt; を呼び出し。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;getSnapshots()&lt;/code&gt; が描画層へ渡す &lt;code&gt;EntitySnapshot[]&lt;/code&gt; を生成。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;World は順序保証のため &lt;code&gt;Map&lt;/code&gt; を使っています。Entity 追加時に &lt;code&gt;_onEnterWorld()&lt;/code&gt; が走り、&lt;code&gt;_ready()&lt;/code&gt; が 1 度だけ実行されます。除去時は &lt;code&gt;_onExitWorld()&lt;/code&gt; で &lt;code&gt;_ready()&lt;/code&gt; の再実行を許可します。&lt;/p&gt;&#xA;&lt;h2 id=&#34;entity-抽象クラス&#34;&gt;Entity 抽象クラス&lt;a class=&#34;anchor&#34; href=&#34;#entity-%e6%8a%bd%e8%b1%a1%e3%82%af%e3%83%a9%e3%82%b9&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Entity&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;TSnapshot&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;EntitySnapshot&lt;/span&gt;&amp;gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;tickRate&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;;      &lt;span style=&#34;color:#75715e&#34;&gt;// デフォルト 1/60 秒&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;tickTimer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 経過時間累積&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;process&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;dt&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tickTimer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dt&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tickTimer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tickRate&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tickTimer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tickRate&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;_process&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tickRate&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_process&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;elapsed&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getSnapshot&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TSnapshot&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;tickrate-と決定性&#34;&gt;tickRate と決定性&lt;a class=&#34;anchor&#34; href=&#34;#tickrate-%e3%81%a8%e6%b1%ba%e5%ae%9a%e6%80%a7&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;tickRate&lt;/code&gt; は Entity ごとの更新周期です。World は &lt;code&gt;dt&lt;/code&gt; をそのまま流すのではなく、&lt;code&gt;tickTimer&lt;/code&gt; に蓄積した上で tickRate を超えた回数だけ &lt;code&gt;_process()&lt;/code&gt; を実行します。これにより、RAF のフレームレートが揺らいでもロジックは固定周期で進行します。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Scheduler</title>
      <link>https://codigrowa-docs.local/docs/runtime/scheduler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://codigrowa-docs.local/docs/runtime/scheduler/</guid>
      <description>&lt;p&gt;&lt;code&gt;engine/Scheduler.ts&lt;/code&gt; は時間ベースの関数実行を担当します。GameLoop の &lt;code&gt;dt&lt;/code&gt; を受け取り、内部に積んだタスクの &lt;code&gt;remaining&lt;/code&gt; 時間を減算し、0 を下回ったタイミングで実行します。&lt;/p&gt;&#xA;&lt;h2 id=&#34;タスクモデル&#34;&gt;タスクモデル&lt;a class=&#34;anchor&#34; href=&#34;#%e3%82%bf%e3%82%b9%e3%82%af%e3%83%a2%e3%83%87%e3%83%ab&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SchedulerTask&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;callback&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; () &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;remaining&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;interval&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;repeat&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;wait(delay, callback)&lt;/code&gt; は一度だけ実行するタスクを登録。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;schedule(callback, interval, { repeat })&lt;/code&gt; はデフォルトで繰り返し（&lt;code&gt;repeat: true&lt;/code&gt;）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;cancel(id)&lt;/code&gt; / &lt;code&gt;clear()&lt;/code&gt; で後始末。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;Game.update&lt;/code&gt; が Scheduler を World より先に呼び出すため、タスク内で Entity の状態を変更しても同じ tick 内で描画に反映されます。&lt;/p&gt;&#xA;&lt;h2 id=&#34;使い所&#34;&gt;使い所&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e3%81%84%e6%89%80&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HUD へ定期的にログを出す（&lt;code&gt;components/game-canvas.tsx&lt;/code&gt; 内参照）。&lt;/li&gt;&#xA;&lt;li&gt;Cutscene のように「数秒待ってから次アクション」を表現する。&lt;/li&gt;&#xA;&lt;li&gt;Entity 内から &lt;code&gt;this.game.wait()&lt;/code&gt; を呼びたい場合は依存注入で Game インスタンスを受け取り、&lt;code&gt;_ready()&lt;/code&gt; でタスク登録・ &lt;code&gt;_onExitWorld()&lt;/code&gt; で &lt;code&gt;cancelTask()&lt;/code&gt; する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;エラーハンドリング&#34;&gt;エラーハンドリング&lt;a class=&#34;anchor&#34; href=&#34;#%e3%82%a8%e3%83%a9%e3%83%bc%e3%83%8f%e3%83%b3%e3%83%89%e3%83%aa%e3%83%b3%e3%82%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;タスク実行中に例外が起こっても Scheduler 自身は落ちません。&lt;code&gt;console.warn()&lt;/code&gt; を出した上で、単発タスクは削除、繰り返しタスクは次のインターバルへ進みます。長時間走り続けるサービスを意識し、repeat タスクでは必ず &lt;code&gt;cancel()&lt;/code&gt; のタイミングを決めておきましょう。&lt;/p&gt;&#xA;&lt;h2 id=&#34;パフォーマンスのコツ&#34;&gt;パフォーマンスのコツ&lt;a class=&#34;anchor&#34; href=&#34;#%e3%83%91%e3%83%95%e3%82%a9%e3%83%bc%e3%83%9e%e3%83%b3%e3%82%b9%e3%81%ae%e3%82%b3%e3%83%84&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;タスク数は &lt;code&gt;Map&lt;/code&gt; で管理しているため数百件程度までなら問題なし。大量登録が必要なら &lt;code&gt;getTaskCount()&lt;/code&gt; を監視し、デバッグ HUD から過剰登録を検知する仕組みを追加すると安全です。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;update(dt)&lt;/code&gt; はタスクが無い場合 O(1) で即 return するため、必要なタイミングでこまめに &lt;code&gt;cancel()&lt;/code&gt; しておくと無駄なループを避けられます。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>GameLoop と状態共有</title>
      <link>https://codigrowa-docs.local/docs/runtime/game-loop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://codigrowa-docs.local/docs/runtime/game-loop/</guid>
      <description>&lt;p&gt;React 側では &lt;code&gt;engine/hooks/useGameLoop.ts&lt;/code&gt; と &lt;code&gt;engine/stores/useGameStore.ts&lt;/code&gt; がゲームエンジンを UI に接続します。&lt;/p&gt;&#xA;&lt;h2 id=&#34;usegameloop-フック&#34;&gt;useGameLoop フック&lt;a class=&#34;anchor&#34; href=&#34;#usegameloop-%e3%83%95%e3%83%83%e3%82%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;useGameLoop&lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;dt&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;game&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;update&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;dt&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}, &lt;span style=&#34;color:#a6e22e&#34;&gt;isRunning&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;game&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;isRunning&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt; の &lt;code&gt;time&lt;/code&gt; から &lt;code&gt;dt&lt;/code&gt;（秒）を算出。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;isRunning&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; のときは RAF を解除し、&lt;code&gt;lastTimeRef&lt;/code&gt; をリセット。&lt;/li&gt;&#xA;&lt;li&gt;ループ中に最新のコールバック参照を使うため &lt;code&gt;useRef&lt;/code&gt; で callback を保持。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;必要に応じて UI 側から任意の &lt;code&gt;Game&lt;/code&gt; インスタンスを渡せます。Expo DevTools のホットリロードでも問題なく再初期化されるよう、&lt;code&gt;useEffect&lt;/code&gt; のクリーンアップで &lt;code&gt;cancelAnimationFrame&lt;/code&gt; を確実に呼んでいます。&lt;/p&gt;&#xA;&lt;h2 id=&#34;zustand-ストア&#34;&gt;Zustand ストア&lt;a class=&#34;anchor&#34; href=&#34;#zustand-%e3%82%b9%e3%83%88%e3%82%a2&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;engine/stores/useGameStore.ts&lt;/code&gt; は &lt;code&gt;Game&lt;/code&gt; を 1 つだけ生成し、UI からは &lt;code&gt;start/pause/resume/stop&lt;/code&gt; をディスパッチできるようにしています。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;setRenderPayload(payload)&lt;/code&gt; が &lt;code&gt;Game.onRender&lt;/code&gt; から届いたデータを &lt;code&gt;tick/elapsed/entities&lt;/code&gt; に反映。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;toggleRunning()&lt;/code&gt; で UI トグルスイッチと同期。&lt;/li&gt;&#xA;&lt;li&gt;ストアはクライアントサイドのみで使うため、サーバーレンダリングの心配は不要。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;GameCanvas&lt;/code&gt; 以外の画面（HUD、デバッグパネル、外部ツール）でも同じストアを購読すれば、最新の World スナップショットを共有できます。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
