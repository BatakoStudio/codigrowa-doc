<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Codigrowa Docs</title>
    <link>https://codigrowa-docs.local/</link>
    <description>Recent content on Codigrowa Docs</description>
    <generator>Hugo</generator>
    <language>ja-jp</language>
    <atom:link href="https://codigrowa-docs.local/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Entity 実装ガイド</title>
      <link>https://codigrowa-docs.local/docs/guides/new-entity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://codigrowa-docs.local/docs/guides/new-entity/</guid>
      <description>&lt;p&gt;このガイドでは新しい Entity を &lt;code&gt;engine/entities/&lt;/code&gt; に追加し、Game へ組み込むまでの流れを説明します。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-クラス定義&#34;&gt;1. クラス定義&lt;a class=&#34;anchor&#34; href=&#34;#1-%e3%82%af%e3%83%a9%e3%82%b9%e5%ae%9a%e7%be%a9&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;engine/entities/MyEntity.ts&lt;/code&gt; を作成。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Entity&lt;/code&gt; を継承し、&lt;code&gt;MyEntitySnapshot&lt;/code&gt; 型を定義。&lt;/li&gt;&#xA;&lt;li&gt;コンストラクタで &lt;code&gt;tickRate&lt;/code&gt; や初期座標を渡す。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;_process(elapsed)&lt;/code&gt; に 1 tick 分のロジックを書く。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;Entity&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;EntitySnapshot&lt;/span&gt; } &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;./Entity&amp;#39;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyEntitySnapshot&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;EntitySnapshot&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;hp&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt; };&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyEntity&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Entity&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;MyEntitySnapshot&lt;/span&gt;&amp;gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hp&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_process() {&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 例: 徐々に減衰&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;hp&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;hp&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;getSnapshot() {&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt; } &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getPosition&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;this.id&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;hp&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;this.hp&lt;/span&gt; };&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-world-へ登録&#34;&gt;2. World へ登録&lt;a class=&#34;anchor&#34; href=&#34;#2-world-%e3%81%b8%e7%99%bb%e9%8c%b2&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;entity&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyEntity&lt;/span&gt;({ &lt;span style=&#34;color:#a6e22e&#34;&gt;tickRate&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;50&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;120&lt;/span&gt; });&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;game&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;addEntity&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;entity&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Game.addEntity&lt;/code&gt; が World 経由で &lt;code&gt;_ready()&lt;/code&gt; を一度だけ呼びます。&lt;/li&gt;&#xA;&lt;li&gt;画面遷移やアンマウント時は &lt;code&gt;game.removeEntity(entity.id)&lt;/code&gt; を必ず実行。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;3-描画スナップショットの更新&#34;&gt;3. 描画スナップショットの更新&lt;a class=&#34;anchor&#34; href=&#34;#3-%e6%8f%8f%e7%94%bb%e3%82%b9%e3%83%8a%e3%83%83%e3%83%97%e3%82%b7%e3%83%a7%e3%83%83%e3%83%88%e3%81%ae%e6%9b%b4%e6%96%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;Skia や React 側が必要とする最小情報だけを &lt;code&gt;getSnapshot()&lt;/code&gt; に詰めます。大きなオブジェクトを渡すと render 毎にシリアライズコストが掛かるため、描画に不要なロジック用フィールドは含めないでください。&lt;/p&gt;</description>
    </item>
    <item>
      <title>GameCanvas / Renderer</title>
      <link>https://codigrowa-docs.local/docs/rendering/game-canvas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://codigrowa-docs.local/docs/rendering/game-canvas/</guid>
      <description>&lt;p&gt;&lt;code&gt;components/game-canvas.tsx&lt;/code&gt; は Game からのスナップショットを &lt;code&gt;@shopify/react-native-skia&lt;/code&gt; で描画するデモ実装です。エンジンの状態を UI に届ける際のベストプラクティスをまとめます。&lt;/p&gt;&#xA;&lt;h2 id=&#34;初期化フロー&#34;&gt;初期化フロー&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9d%e6%9c%9f%e5%8c%96%e3%83%95%e3%83%ad%e3%83%bc&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;startGame({ reset: true })&lt;/code&gt; を &lt;code&gt;useEffect&lt;/code&gt; で 1 度だけ呼び、GameLoop を開始。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;LinearMover&lt;/code&gt; のような Entity をインスタンス化して &lt;code&gt;game.addEntity()&lt;/code&gt; で登録。&lt;/li&gt;&#xA;&lt;li&gt;クリーンアップ時に &lt;code&gt;game.removeEntity(entity.id)&lt;/code&gt; を忘れない。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;レンダリング購読&#34;&gt;レンダリング購読&lt;a class=&#34;anchor&#34; href=&#34;#%e3%83%ac%e3%83%b3%e3%83%80%e3%83%aa%e3%83%b3%e3%82%b0%e8%b3%bc%e8%aa%ad&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;useEffect&lt;/span&gt;(() &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsubscribe&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;game&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onRender&lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;payload&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;setRenderPayload&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;payload&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  });&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsubscribe&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}, [&lt;span style=&#34;color:#a6e22e&#34;&gt;game&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;setRenderPayload&lt;/span&gt;]);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Zustand ストアの &lt;code&gt;entities&lt;/code&gt; を &lt;code&gt;Canvas&lt;/code&gt; に流し込むことで、UI 層は Game の内部構造に触れずに描画を完了できます。&lt;code&gt;LinearMoverSnapshot&lt;/code&gt; のように型ガードを挟めば、Canvas 上で扱うデータを限定できます。&lt;/p&gt;&#xA;&lt;h2 id=&#34;scheduler-を使った-hud&#34;&gt;Scheduler を使った HUD&lt;a class=&#34;anchor&#34; href=&#34;#scheduler-%e3%82%92%e4%bd%bf%e3%81%a3%e3%81%9f-hud&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;GameCanvas&lt;/code&gt; では &lt;code&gt;game.schedule()&lt;/code&gt; と &lt;code&gt;game.wait()&lt;/code&gt; を使い、定期ログと遅延ログを生成しています。&lt;code&gt;setFunctionLogs&lt;/code&gt; で最新 4 件だけ表示する仕組みは、Scheduler の動作確認に最適です。&lt;/p&gt;&#xA;&lt;h2 id=&#34;skia-との結合ポイント&#34;&gt;Skia との結合ポイント&lt;a class=&#34;anchor&#34; href=&#34;#skia-%e3%81%a8%e3%81%ae%e7%b5%90%e5%90%88%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Canvas&lt;/code&gt; 内では &lt;code&gt;entities&lt;/code&gt; のスナップショットをループして &lt;code&gt;Rect&lt;/code&gt; を描画。&lt;/li&gt;&#xA;&lt;li&gt;描画に必要な情報は &lt;code&gt;getSnapshot()&lt;/code&gt; の戻り値へ追加する。例: &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, &lt;code&gt;color&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;UI スレッドから World を直接触らず、描画で使う値はすべてスナップショットから取得する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;応用-別-renderer-への差し替え&#34;&gt;応用: 別 Renderer への差し替え&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bf%9c%e7%94%a8-%e5%88%a5-renderer-%e3%81%b8%e3%81%ae%e5%b7%ae%e3%81%97%e6%9b%bf%e3%81%88&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;同じ &lt;code&gt;Game.onRender()&lt;/code&gt; を WebGL や Three.js など別のレンダラへ接続しても問題ありません。&lt;code&gt;Game&lt;/code&gt; はレンダラ非依存なので、&lt;strong&gt;1 つの Game インスタンスを複数 Renderer が購読する&lt;/strong&gt; 構成も可能です（HUD + Canvas など）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>アーキテクチャ概観</title>
      <link>https://codigrowa-docs.local/docs/runtime/architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://codigrowa-docs.local/docs/runtime/architecture/</guid>
      <description>&lt;p&gt;Codigrowa のゲームエンジンは &lt;strong&gt;GameLoop → Scheduler → World → Entity → Renderer&lt;/strong&gt; という鎖で構成されています。Expo（React Native）上では &lt;code&gt;requestAnimationFrame&lt;/code&gt; を起点に時間が進み、React 側のコンポーネントは &lt;code&gt;Game.onRender()&lt;/code&gt; から受け取るスナップショットだけで描画を完結させます。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;useGameLoop (engine/hooks/useGameLoop.ts)&#xA;        │&#xA;        ▼&#xA;┌──────────────┐&#xA;│ Game         │  ← ランタイム中枢&#xA;│  • Scheduler │  ← 関数単位 tick&#xA;│  • World     │  ← Entity 単位 tick&#xA;└──────────────┘&#xA;        │&#xA;        ▼&#xA;Canvas Renderer (components/game-canvas.tsx)&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;データフロー&#34;&gt;データフロー&lt;a class=&#34;anchor&#34; href=&#34;#%e3%83%87%e3%83%bc%e3%82%bf%e3%83%95%e3%83%ad%e3%83%bc&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;useGameLoop&lt;/code&gt; が &lt;code&gt;requestAnimationFrame&lt;/code&gt; から &lt;code&gt;dt&lt;/code&gt;（秒）を算出し &lt;code&gt;Game.update(dt)&lt;/code&gt; を連続呼び出し。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Game.update&lt;/code&gt; はまず &lt;code&gt;Scheduler.update(dt)&lt;/code&gt; を処理し、待機中のコールバックを実行。&lt;/li&gt;&#xA;&lt;li&gt;続いて &lt;code&gt;World.process(dt)&lt;/code&gt; が全 &lt;code&gt;Entity&lt;/code&gt; の &lt;code&gt;process()&lt;/code&gt; を tick に合わせて回す。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Game.notifyRender()&lt;/code&gt; が World からのスナップショットをまとめ、&lt;code&gt;onRender&lt;/code&gt; 購読者（HUD や Skia Canvas）へ配布。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;描画層は &lt;code&gt;GameRenderPayload&lt;/code&gt; を受け取るだけで済むため、World/Entity の内部状態を UI から直接 mutate しません。これにより、レンダリングとロジックの責務分離とデバッグ容易性を両立しています。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Game クラス</title>
      <link>https://codigrowa-docs.local/docs/runtime/game/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://codigrowa-docs.local/docs/runtime/game/</guid>
      <description>&lt;p&gt;&lt;code&gt;engine/Game.ts&lt;/code&gt; はランタイムの司令塔です。World と Scheduler を束ね、1 tick ごとに状態更新と描画用スナップショット生成を行います。&lt;/p&gt;&#xA;&lt;h2 id=&#34;ライフサイクル-api&#34;&gt;ライフサイクル API&lt;a class=&#34;anchor&#34; href=&#34;#%e3%83%a9%e3%82%a4%e3%83%95%e3%82%b5%e3%82%a4%e3%82%af%e3%83%ab-api&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;メソッド&lt;/th&gt;&#xA;          &lt;th&gt;用途&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;start({ reset?: boolean })&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;GameLoop 起動。&lt;code&gt;reset&lt;/code&gt; で &lt;code&gt;elapsed&lt;/code&gt; / &lt;code&gt;tick&lt;/code&gt; を初期化し即スナップショット配布。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;pause()&lt;/code&gt; / &lt;code&gt;resume()&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;update()&lt;/code&gt; の実行を一時停止／再開。Zustand ストアから UI でトグル。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;stop()&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;ループ停止 + Scheduler タスク破棄。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;update(dt: number)&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Scheduler.update(dt)&lt;/code&gt; → &lt;code&gt;World.process(dt)&lt;/code&gt; → &lt;code&gt;notifyRender()&lt;/code&gt; の順で実行。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;&lt;code&gt;useGameLoop&lt;/code&gt; から渡される &lt;code&gt;dt&lt;/code&gt;（秒）だけを頼りに Game は決定的に進行します。React 側で &lt;code&gt;Game&lt;/code&gt; や &lt;code&gt;World&lt;/code&gt; を直接触る場合は、状態破壊を避けるためなるべく API 経由（&lt;code&gt;addEntity&lt;/code&gt;, &lt;code&gt;wait&lt;/code&gt; など）で操作してください。&lt;/p&gt;&#xA;&lt;h2 id=&#34;world--scheduler-依存差し替え&#34;&gt;World / Scheduler 依存差し替え&lt;a class=&#34;anchor&#34; href=&#34;#world--scheduler-%e4%be%9d%e5%ad%98%e5%b7%ae%e3%81%97%e6%9b%bf%e3%81%88&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;コンストラクタでは &lt;code&gt;new Game({ world, scheduler })&lt;/code&gt; としてテスト用のモックを注入できます。既存インスタンスを入れ替える場合は &lt;code&gt;setWorld()&lt;/code&gt; / &lt;code&gt;setScheduler()&lt;/code&gt; を利用します。&lt;/p&gt;</description>
    </item>
    <item>
      <title>デバッグ &amp; 運用</title>
      <link>https://codigrowa-docs.local/docs/guides/debugging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://codigrowa-docs.local/docs/guides/debugging/</guid>
      <description>&lt;p&gt;エンジンを拡張する際に役立つ検証フローとチェックリストです。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-ログと-hud&#34;&gt;1. ログと HUD&lt;a class=&#34;anchor&#34; href=&#34;#1-%e3%83%ad%e3%82%b0%e3%81%a8-hud&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Game.update&lt;/code&gt; は &lt;code&gt;__DEV__&lt;/code&gt; 時に &lt;code&gt;dt&lt;/code&gt; をログ出力します。大量に出る場合は &lt;code&gt;expo start --no-dev&lt;/code&gt; で実機挙動を確認。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Game.onRender&lt;/code&gt; から受け取る &lt;code&gt;GameRenderPayload&lt;/code&gt; を HUD 表示し、&lt;code&gt;elapsed&lt;/code&gt; / &lt;code&gt;tick&lt;/code&gt; / &lt;code&gt;entities.length&lt;/code&gt; をリアルタイムに監視。&lt;code&gt;components/game-canvas.tsx&lt;/code&gt; の &lt;code&gt;functionLogs&lt;/code&gt; 実装を流用できます。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2-テスト駆動のすすめ&#34;&gt;2. テスト駆動のすすめ&lt;a class=&#34;anchor&#34; href=&#34;#2-%e3%83%86%e3%82%b9%e3%83%88%e9%a7%86%e5%8b%95%e3%81%ae%e3%81%99%e3%81%99%e3%82%81&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;World&lt;/code&gt; と &lt;code&gt;Entity&lt;/code&gt; は純粋な TypeScript クラスなので Jest で単体テスト可能。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Scheduler&lt;/code&gt; は &lt;code&gt;update(dt)&lt;/code&gt; を段階的に呼び、&lt;code&gt;task.callback&lt;/code&gt; が発火するかで検証できます。&lt;code&gt;getTaskCount()&lt;/code&gt; を監視すればリーク検知が容易です。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;3-典型的なトラブルシュート&#34;&gt;3. 典型的なトラブルシュート&lt;a class=&#34;anchor&#34; href=&#34;#3-%e5%85%b8%e5%9e%8b%e7%9a%84%e3%81%aa%e3%83%88%e3%83%a9%e3%83%96%e3%83%ab%e3%82%b7%e3%83%a5%e3%83%bc%e3%83%88&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;症状&lt;/th&gt;&#xA;          &lt;th&gt;対処&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Entity が停止する&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;tickRate&lt;/code&gt; が大きすぎて &lt;code&gt;_process&lt;/code&gt; が呼ばれていない可能性。&lt;code&gt;__DEV__&lt;/code&gt; ログで &lt;code&gt;dt&lt;/code&gt; を確認。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Renderer に反映されない&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;getSnapshot()&lt;/code&gt; で必要なフィールドを返しているか確認。&lt;code&gt;GameCanvas&lt;/code&gt; 側で型ガードを追加。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Scheduler タスクが残り続ける&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;game.cancelTask(id)&lt;/code&gt; を &lt;code&gt;useEffect&lt;/code&gt; のクリーンアップで呼ぶ。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;複数画面で Game を共有したい&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;useGameStore&lt;/code&gt; の &lt;code&gt;game&lt;/code&gt; インスタンスをシングルトンとして取り回し、各画面で &lt;code&gt;onRender&lt;/code&gt; を個別登録。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;4-将来の拡張ポイント&#34;&gt;4. 将来の拡張ポイント&lt;a class=&#34;anchor&#34; href=&#34;#4-%e5%b0%86%e6%9d%a5%e3%81%ae%e6%8b%a1%e5%bc%b5%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;docs/game_engine_develop_plan.md&lt;/code&gt; に記載されている Step #4 以降（タップ入力、Signal、Sprite 切替など）は現行アーキテクチャを前提としています。API 変更時は互換性を保つため、Hugo ドキュメント内の該当章も更新してください。&lt;/p&gt;</description>
    </item>
    <item>
      <title>World &amp; Entity</title>
      <link>https://codigrowa-docs.local/docs/runtime/world-entity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://codigrowa-docs.local/docs/runtime/world-entity/</guid>
      <description>&lt;p&gt;&lt;code&gt;engine/World.ts&lt;/code&gt; と &lt;code&gt;engine/entities/Entity.ts&lt;/code&gt; はエンジンの心臓部です。World が Entity を束ね、Entity は tickRate ごとに &lt;code&gt;_process()&lt;/code&gt; を実行します。&lt;/p&gt;&#xA;&lt;h2 id=&#34;world-の責務&#34;&gt;World の責務&lt;a class=&#34;anchor&#34; href=&#34;#world-%e3%81%ae%e8%b2%ac%e5%8b%99&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;addEntity(entity)&lt;/code&gt; / &lt;code&gt;removeEntity(id)&lt;/code&gt; / &lt;code&gt;clear()&lt;/code&gt; で登録を管理。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;process(dt)&lt;/code&gt; で全 Entity の &lt;code&gt;process(dt)&lt;/code&gt; を呼び出し。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;getSnapshots()&lt;/code&gt; が描画層へ渡す &lt;code&gt;EntitySnapshot[]&lt;/code&gt; を生成。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;World は順序保証のため &lt;code&gt;Map&lt;/code&gt; を使っています。Entity 追加時に &lt;code&gt;_onEnterWorld()&lt;/code&gt; が走り、&lt;code&gt;_ready()&lt;/code&gt; が 1 度だけ実行されます。除去時は &lt;code&gt;_onExitWorld()&lt;/code&gt; で &lt;code&gt;_ready()&lt;/code&gt; の再実行を許可します。&lt;/p&gt;&#xA;&lt;h2 id=&#34;entity-抽象クラス&#34;&gt;Entity 抽象クラス&lt;a class=&#34;anchor&#34; href=&#34;#entity-%e6%8a%bd%e8%b1%a1%e3%82%af%e3%83%a9%e3%82%b9&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Entity&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;TSnapshot&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;EntitySnapshot&lt;/span&gt;&amp;gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;tickRate&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;;      &lt;span style=&#34;color:#75715e&#34;&gt;// デフォルト 1/60 秒&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;tickTimer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 経過時間累積&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;process&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;dt&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tickTimer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dt&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tickTimer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tickRate&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tickTimer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tickRate&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;_process&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tickRate&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_process&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;elapsed&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getSnapshot&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TSnapshot&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;tickrate-と決定性&#34;&gt;tickRate と決定性&lt;a class=&#34;anchor&#34; href=&#34;#tickrate-%e3%81%a8%e6%b1%ba%e5%ae%9a%e6%80%a7&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;tickRate&lt;/code&gt; は Entity ごとの更新周期です。World は &lt;code&gt;dt&lt;/code&gt; をそのまま流すのではなく、&lt;code&gt;tickTimer&lt;/code&gt; に蓄積した上で tickRate を超えた回数だけ &lt;code&gt;_process()&lt;/code&gt; を実行します。これにより、RAF のフレームレートが揺らいでもロジックは固定周期で進行します。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Scheduler</title>
      <link>https://codigrowa-docs.local/docs/runtime/scheduler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://codigrowa-docs.local/docs/runtime/scheduler/</guid>
      <description>&lt;p&gt;&lt;code&gt;engine/Scheduler.ts&lt;/code&gt; は時間ベースの関数実行を担当します。GameLoop の &lt;code&gt;dt&lt;/code&gt; を受け取り、内部に積んだタスクの &lt;code&gt;remaining&lt;/code&gt; 時間を減算し、0 を下回ったタイミングで実行します。&lt;/p&gt;&#xA;&lt;h2 id=&#34;タスクモデル&#34;&gt;タスクモデル&lt;a class=&#34;anchor&#34; href=&#34;#%e3%82%bf%e3%82%b9%e3%82%af%e3%83%a2%e3%83%87%e3%83%ab&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SchedulerTask&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;callback&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; () &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;remaining&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;interval&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;repeat&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;wait(delay, callback)&lt;/code&gt; は一度だけ実行するタスクを登録。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;schedule(callback, interval, { repeat })&lt;/code&gt; はデフォルトで繰り返し（&lt;code&gt;repeat: true&lt;/code&gt;）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;cancel(id)&lt;/code&gt; / &lt;code&gt;clear()&lt;/code&gt; で後始末。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;Game.update&lt;/code&gt; が Scheduler を World より先に呼び出すため、タスク内で Entity の状態を変更しても同じ tick 内で描画に反映されます。&lt;/p&gt;&#xA;&lt;h2 id=&#34;使い所&#34;&gt;使い所&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e3%81%84%e6%89%80&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HUD へ定期的にログを出す（&lt;code&gt;components/game-canvas.tsx&lt;/code&gt; 内参照）。&lt;/li&gt;&#xA;&lt;li&gt;Cutscene のように「数秒待ってから次アクション」を表現する。&lt;/li&gt;&#xA;&lt;li&gt;Entity 内から &lt;code&gt;this.game.wait()&lt;/code&gt; を呼びたい場合は依存注入で Game インスタンスを受け取り、&lt;code&gt;_ready()&lt;/code&gt; でタスク登録・ &lt;code&gt;_onExitWorld()&lt;/code&gt; で &lt;code&gt;cancelTask()&lt;/code&gt; する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;エラーハンドリング&#34;&gt;エラーハンドリング&lt;a class=&#34;anchor&#34; href=&#34;#%e3%82%a8%e3%83%a9%e3%83%bc%e3%83%8f%e3%83%b3%e3%83%89%e3%83%aa%e3%83%b3%e3%82%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;タスク実行中に例外が起こっても Scheduler 自身は落ちません。&lt;code&gt;console.warn()&lt;/code&gt; を出した上で、単発タスクは削除、繰り返しタスクは次のインターバルへ進みます。長時間走り続けるサービスを意識し、repeat タスクでは必ず &lt;code&gt;cancel()&lt;/code&gt; のタイミングを決めておきましょう。&lt;/p&gt;&#xA;&lt;h2 id=&#34;パフォーマンスのコツ&#34;&gt;パフォーマンスのコツ&lt;a class=&#34;anchor&#34; href=&#34;#%e3%83%91%e3%83%95%e3%82%a9%e3%83%bc%e3%83%9e%e3%83%b3%e3%82%b9%e3%81%ae%e3%82%b3%e3%83%84&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;タスク数は &lt;code&gt;Map&lt;/code&gt; で管理しているため数百件程度までなら問題なし。大量登録が必要なら &lt;code&gt;getTaskCount()&lt;/code&gt; を監視し、デバッグ HUD から過剰登録を検知する仕組みを追加すると安全です。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;update(dt)&lt;/code&gt; はタスクが無い場合 O(1) で即 return するため、必要なタイミングでこまめに &lt;code&gt;cancel()&lt;/code&gt; しておくと無駄なループを避けられます。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>GameLoop と状態共有</title>
      <link>https://codigrowa-docs.local/docs/runtime/game-loop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://codigrowa-docs.local/docs/runtime/game-loop/</guid>
      <description>&lt;p&gt;React 側では &lt;code&gt;engine/hooks/useGameLoop.ts&lt;/code&gt; と &lt;code&gt;engine/stores/useGameStore.ts&lt;/code&gt; がゲームエンジンを UI に接続します。&lt;/p&gt;&#xA;&lt;h2 id=&#34;usegameloop-フック&#34;&gt;useGameLoop フック&lt;a class=&#34;anchor&#34; href=&#34;#usegameloop-%e3%83%95%e3%83%83%e3%82%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;useGameLoop&lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;dt&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;game&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;update&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;dt&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}, &lt;span style=&#34;color:#a6e22e&#34;&gt;isRunning&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;game&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;isRunning&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt; の &lt;code&gt;time&lt;/code&gt; から &lt;code&gt;dt&lt;/code&gt;（秒）を算出。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;isRunning&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; のときは RAF を解除し、&lt;code&gt;lastTimeRef&lt;/code&gt; をリセット。&lt;/li&gt;&#xA;&lt;li&gt;ループ中に最新のコールバック参照を使うため &lt;code&gt;useRef&lt;/code&gt; で callback を保持。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;必要に応じて UI 側から任意の &lt;code&gt;Game&lt;/code&gt; インスタンスを渡せます。Expo DevTools のホットリロードでも問題なく再初期化されるよう、&lt;code&gt;useEffect&lt;/code&gt; のクリーンアップで &lt;code&gt;cancelAnimationFrame&lt;/code&gt; を確実に呼んでいます。&lt;/p&gt;&#xA;&lt;h2 id=&#34;zustand-ストア&#34;&gt;Zustand ストア&lt;a class=&#34;anchor&#34; href=&#34;#zustand-%e3%82%b9%e3%83%88%e3%82%a2&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;engine/stores/useGameStore.ts&lt;/code&gt; は &lt;code&gt;Game&lt;/code&gt; を 1 つだけ生成し、UI からは &lt;code&gt;start/pause/resume/stop&lt;/code&gt; をディスパッチできるようにしています。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;setRenderPayload(payload)&lt;/code&gt; が &lt;code&gt;Game.onRender&lt;/code&gt; から届いたデータを &lt;code&gt;tick/elapsed/entities&lt;/code&gt; に反映。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;toggleRunning()&lt;/code&gt; で UI トグルスイッチと同期。&lt;/li&gt;&#xA;&lt;li&gt;ストアはクライアントサイドのみで使うため、サーバーレンダリングの心配は不要。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;GameCanvas&lt;/code&gt; 以外の画面（HUD、デバッグパネル、外部ツール）でも同じストアを購読すれば、最新の World スナップショットを共有できます。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
