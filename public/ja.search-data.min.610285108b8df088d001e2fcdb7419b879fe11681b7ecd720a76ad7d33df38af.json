[{"id":0,"href":"/docs/","title":"Codigrowa Game Engine","section":"Codigrowa Docs","content":"Expo + react-native-skia 上で動作する最小ゲームエンジンの仕様と実装ガイドです。engine/ ディレクトリのコードを中心に、ランタイム構成・API・運用フローを整理しています。\n最初に読む: アーキテクチャ概観 新しい Entity を追加したい: Entity 実装ガイド UI へ組み込みたい: GameCanvas / Renderer 連携 "},{"id":1,"href":"/docs/runtime/","title":"ランタイム","section":"Codigrowa Game Engine","content":"GameLoop / Scheduler / World / Entity といった実行時コンポーネントの仕様をまとめています。\n"},{"id":2,"href":"/docs/rendering/","title":"Renderer","section":"Codigrowa Game Engine","content":"Game から受け取ったスナップショットを描画層へ接続するためのガイドです。\n"},{"id":3,"href":"/docs/guides/","title":"ガイド","section":"Codigrowa Game Engine","content":"エンジンを利用・拡張するための実践手順や運用ノウハウをまとめています。\n"},{"id":4,"href":"/docs/guides/new-entity/","title":"Entity 実装ガイド","section":"ガイド","content":"このガイドでは新しい Entity を engine/entities/ に追加し、Game へ組み込むまでの流れを説明します。\n1. クラス定義# engine/entities/MyEntity.ts を作成。 Entity を継承し、MyEntitySnapshot 型を定義。 コンストラクタで tickRate や初期座標を渡す。 _process(elapsed) に 1 tick 分のロジックを書く。 import { Entity, EntitySnapshot } from \u0026#39;./Entity\u0026#39;; type MyEntitySnapshot = EntitySnapshot \u0026amp; { hp: number }; export class MyEntity extends Entity\u0026lt;MyEntitySnapshot\u0026gt; { private hp = 100; protected _process() { // 例: 徐々に減衰 this.hp = Math.max(0, this.hp - 1); } getSnapshot() { const { x, y } = this.getPosition(); return { id: this.id, x, y, hp: this.hp }; } }2. World へ登録# const entity = new MyEntity({ tickRate: 1 / 30, x: 50, y: 120 }); game.addEntity(entity); Game.addEntity が World 経由で _ready() を一度だけ呼びます。 画面遷移やアンマウント時は game.removeEntity(entity.id) を必ず実行。 3. 描画スナップショットの更新# Skia や React 側が必要とする最小情報だけを getSnapshot() に詰めます。大きなオブジェクトを渡すと render 毎にシリアライズコストが掛かるため、描画に不要なロジック用フィールドは含めないでください。\n4. Scheduler / Signal 連携# 時間ベースの処理が必要なら、Game をコンストラクタで受け取り this.game.wait() を _ready() で設定。 今後追加予定の Signal システムとも疎結合にできるよう、World への参照が必要な場合は _ready() の中で安全にアクセスしましょう。 5. デバッグ Tips# __DEV__ フラグ下では Game.update が console.log を出すので挙動確認に有効。 Game.onRender に HUD をぶら下げて EntitySnapshot をそのまま表示すると、位置や内部値を即座に確認できます。 これで他の開発者も Entity を追加するだけで GameLoop に乗り、Renderer が自動的に新スナップショットを描画してくれるようになります。\n"},{"id":5,"href":"/docs/rendering/game-canvas/","title":"GameCanvas / Renderer","section":"Renderer","content":"components/game-canvas.tsx は Game からのスナップショットを @shopify/react-native-skia で描画するデモ実装です。エンジンの状態を UI に届ける際のベストプラクティスをまとめます。\n初期化フロー# startGame({ reset: true }) を useEffect で 1 度だけ呼び、GameLoop を開始。 LinearMover のような Entity をインスタンス化して game.addEntity() で登録。 クリーンアップ時に game.removeEntity(entity.id) を忘れない。 レンダリング購読# useEffect(() =\u0026gt; { const unsubscribe = game.onRender((payload) =\u0026gt; { setRenderPayload(payload); }); return unsubscribe; }, [game, setRenderPayload]);Zustand ストアの entities を Canvas に流し込むことで、UI 層は Game の内部構造に触れずに描画を完了できます。LinearMoverSnapshot のように型ガードを挟めば、Canvas 上で扱うデータを限定できます。\nScheduler を使った HUD# GameCanvas では game.schedule() と game.wait() を使い、定期ログと遅延ログを生成しています。setFunctionLogs で最新 4 件だけ表示する仕組みは、Scheduler の動作確認に最適です。\nSkia との結合ポイント# Canvas 内では entities のスナップショットをループして Rect を描画。 描画に必要な情報は getSnapshot() の戻り値へ追加する。例: width, height, color。 UI スレッドから World を直接触らず、描画で使う値はすべてスナップショットから取得する。 応用: 別 Renderer への差し替え# 同じ Game.onRender() を WebGL や Three.js など別のレンダラへ接続しても問題ありません。Game はレンダラ非依存なので、1 つの Game インスタンスを複数 Renderer が購読する 構成も可能です（HUD + Canvas など）。\n"},{"id":6,"href":"/docs/runtime/architecture/","title":"アーキテクチャ概観","section":"ランタイム","content":"Codigrowa のゲームエンジンは GameLoop → Scheduler → World → Entity → Renderer という鎖で構成されています。Expo（React Native）上では requestAnimationFrame を起点に時間が進み、React 側のコンポーネントは Game.onRender() から受け取るスナップショットだけで描画を完結させます。\nuseGameLoop (engine/hooks/useGameLoop.ts) │ ▼ ┌──────────────┐ │ Game │ ← ランタイム中枢 │ • Scheduler │ ← 関数単位 tick │ • World │ ← Entity 単位 tick └──────────────┘ │ ▼ Canvas Renderer (components/game-canvas.tsx)データフロー# useGameLoop が requestAnimationFrame から dt（秒）を算出し Game.update(dt) を連続呼び出し。 Game.update はまず Scheduler.update(dt) を処理し、待機中のコールバックを実行。 続いて World.process(dt) が全 Entity の process() を tick に合わせて回す。 Game.notifyRender() が World からのスナップショットをまとめ、onRender 購読者（HUD や Skia Canvas）へ配布。 描画層は GameRenderPayload を受け取るだけで済むため、World/Entity の内部状態を UI から直接 mutate しません。これにより、レンダリングとロジックの責務分離とデバッグ容易性を両立しています。\n主要ディレクトリ# ディレクトリ 役割 engine/Game.ts GameLoop とサブシステム統合。start/pause/resume などのライフサイクル API を提供。 engine/World.ts Entity 管理・スナップショット生成。 engine/entities/ Entity 抽象クラスと具象実装（例: LinearMover）。 engine/Scheduler.ts 時間ベースの関数実行を管理。 engine/hooks/useGameLoop.ts React フックで RAF ループを抽象化。 components/game-canvas.tsx Game と react-native-skia を橋渡しし、デモ描画や HUD を担う。 以降の章で各レイヤーの API と実装パターンを詳述します。\n"},{"id":7,"href":"/docs/runtime/game/","title":"Game クラス","section":"ランタイム","content":"engine/Game.ts はランタイムの司令塔です。World と Scheduler を束ね、1 tick ごとに状態更新と描画用スナップショット生成を行います。\nライフサイクル API# メソッド 用途 start({ reset?: boolean }) GameLoop 起動。reset で elapsed / tick を初期化し即スナップショット配布。 pause() / resume() update() の実行を一時停止／再開。Zustand ストアから UI でトグル。 stop() ループ停止 + Scheduler タスク破棄。 update(dt: number) Scheduler.update(dt) → World.process(dt) → notifyRender() の順で実行。 useGameLoop から渡される dt（秒）だけを頼りに Game は決定的に進行します。React 側で Game や World を直接触る場合は、状態破壊を避けるためなるべく API 経由（addEntity, wait など）で操作してください。\nWorld / Scheduler 依存差し替え# コンストラクタでは new Game({ world, scheduler }) としてテスト用のモックを注入できます。既存インスタンスを入れ替える場合は setWorld() / setScheduler() を利用します。\nエンティティ管理ショートカット# addEntity(entity: Entity) / removeEntity(id) getWorld() で低レベル API へアクセス可能（例: デバッグ HUD が world.getSnapshots() を直接参照するなど） World へ登録すると Entity._onEnterWorld() が発火し、_ready() による初期化フックが 1 度だけ呼ばれます。\nScheduler の委譲 API# メソッド 説明 wait(delay, cb) 指定秒数後に 1 度だけ実行。 schedule(cb, interval, { repeat }) 周期タスク。repeat: false で単発化。 cancelTask(id) 登録済みタスクを停止。HUD などのアンマウント時に必ず呼ぶ。 clearScheduler() 全予約を削除。 Game.update が Scheduler.update を必ず先に呼ぶため、Entity 内で wait/schedule を使うと ロジック → 描画 の順序が保証されます。\nレンダリングサブスク# Game.onRender(cb) で購読すると以下の GameRenderPayload が届きます。\n{ elapsed: number; // 累計経過秒 tick: number; // update 呼び出し回数 entities: EntitySnapshot[]; // World からの描画向けスナップショット }components/game-canvas.tsx ではこの payload をそのまま Zustand ストアに流しており、Skia Canvas は UI 状態だけで描画を再構築しています。購読解除関数が返るので、React の useEffect で登録したら必ずクリーンアップしてください。\n"},{"id":8,"href":"/docs/guides/debugging/","title":"デバッグ \u0026 運用","section":"ガイド","content":"エンジンを拡張する際に役立つ検証フローとチェックリストです。\n1. ログと HUD# Game.update は __DEV__ 時に dt をログ出力します。大量に出る場合は expo start --no-dev で実機挙動を確認。 Game.onRender から受け取る GameRenderPayload を HUD 表示し、elapsed / tick / entities.length をリアルタイムに監視。components/game-canvas.tsx の functionLogs 実装を流用できます。 2. テスト駆動のすすめ# World と Entity は純粋な TypeScript クラスなので Jest で単体テスト可能。 Scheduler は update(dt) を段階的に呼び、task.callback が発火するかで検証できます。getTaskCount() を監視すればリーク検知が容易です。 3. 典型的なトラブルシュート# 症状 対処 Entity が停止する tickRate が大きすぎて _process が呼ばれていない可能性。__DEV__ ログで dt を確認。 Renderer に反映されない getSnapshot() で必要なフィールドを返しているか確認。GameCanvas 側で型ガードを追加。 Scheduler タスクが残り続ける game.cancelTask(id) を useEffect のクリーンアップで呼ぶ。 複数画面で Game を共有したい useGameStore の game インスタンスをシングルトンとして取り回し、各画面で onRender を個別登録。 4. 将来の拡張ポイント# docs/game_engine_develop_plan.md に記載されている Step #4 以降（タップ入力、Signal、Sprite 切替など）は現行アーキテクチャを前提としています。API 変更時は互換性を保つため、Hugo ドキュメント内の該当章も更新してください。\n5. 推奨コマンド# # Expo プロジェクトで lint npm run lint # Hugo ドキュメントのローカルプレビュー cd codigrowa-doc hugo server --buildDrafts --disableFastRenderドキュメントと実装をセットで更新し、他のエンジニアが codigrowa-doc を見るだけでエンジンを扱える状態を維持しましょう。\n"},{"id":9,"href":"/docs/runtime/world-entity/","title":"World \u0026 Entity","section":"ランタイム","content":"engine/World.ts と engine/entities/Entity.ts はエンジンの心臓部です。World が Entity を束ね、Entity は tickRate ごとに _process() を実行します。\nWorld の責務# addEntity(entity) / removeEntity(id) / clear() で登録を管理。 process(dt) で全 Entity の process(dt) を呼び出し。 getSnapshots() が描画層へ渡す EntitySnapshot[] を生成。 World は順序保証のため Map を使っています。Entity 追加時に _onEnterWorld() が走り、_ready() が 1 度だけ実行されます。除去時は _onExitWorld() で _ready() の再実行を許可します。\nEntity 抽象クラス# abstract class Entity\u0026lt;TSnapshot extends EntitySnapshot\u0026gt; { tickRate: number; // デフォルト 1/60 秒 private tickTimer = 0; // 経過時間累積 process(dt: number) { this.tickTimer += dt; while (this.tickTimer \u0026gt;= this.tickRate) { this.tickTimer -= this.tickRate; this._process(this.tickRate); } } protected abstract _process(elapsed: number): void; abstract getSnapshot(): TSnapshot; }tickRate と決定性# tickRate は Entity ごとの更新周期です。World は dt をそのまま流すのではなく、tickTimer に蓄積した上で tickRate を超えた回数だけ _process() を実行します。これにより、RAF のフレームレートが揺らいでもロジックは固定周期で進行します。\n座標とスナップショット# Entity には setPosition(x, y) / getPosition() などの基本アクセサがあり、getSnapshot() で描画層へ公開するデータ構造を自由に定義できます。たとえば LinearMover は以下のようなスナップショットを返しています。\nexport type LinearMoverSnapshot = EntitySnapshot \u0026amp; { x: number; y: number; width: number; height: number; color: string; };ライフサイクルフック# フック タイミング 用途 _init() コンストラクタ内で同期呼び出し 依存注入や初期値計算。非同期処理は避ける。 _ready() World に追加された瞬間に 1 回 World 参照が必要な初期化（例: Signal 登録）。 _process(elapsed) tick ごと ゲームロジック本体。 _onExitWorld() World から削除時 _ready 再実行を許可。リソース解放ここで。 例: LinearMover# engine/entities/LinearMover.ts は x 軸をループ移動するデモ Entity です。tickRate を個別に指定すると異なる速度・フレームレートでも破綻なく動くことが確認できます。GameCanvas では 3 つの LinearMover を登録し、World.getSnapshots() 経由で矩形描画しています。\n"},{"id":10,"href":"/docs/runtime/scheduler/","title":"Scheduler","section":"ランタイム","content":"engine/Scheduler.ts は時間ベースの関数実行を担当します。GameLoop の dt を受け取り、内部に積んだタスクの remaining 時間を減算し、0 を下回ったタイミングで実行します。\nタスクモデル# type SchedulerTask = { id: string; callback: () =\u0026gt; void; remaining: number; interval: number; repeat: boolean; }; wait(delay, callback) は一度だけ実行するタスクを登録。 schedule(callback, interval, { repeat }) はデフォルトで繰り返し（repeat: true）。 cancel(id) / clear() で後始末。 Game.update が Scheduler を World より先に呼び出すため、タスク内で Entity の状態を変更しても同じ tick 内で描画に反映されます。\n使い所# HUD へ定期的にログを出す（components/game-canvas.tsx 内参照）。 Cutscene のように「数秒待ってから次アクション」を表現する。 Entity 内から this.game.wait() を呼びたい場合は依存注入で Game インスタンスを受け取り、_ready() でタスク登録・ _onExitWorld() で cancelTask() する。 エラーハンドリング# タスク実行中に例外が起こっても Scheduler 自身は落ちません。console.warn() を出した上で、単発タスクは削除、繰り返しタスクは次のインターバルへ進みます。長時間走り続けるサービスを意識し、repeat タスクでは必ず cancel() のタイミングを決めておきましょう。\nパフォーマンスのコツ# タスク数は Map で管理しているため数百件程度までなら問題なし。大量登録が必要なら getTaskCount() を監視し、デバッグ HUD から過剰登録を検知する仕組みを追加すると安全です。 update(dt) はタスクが無い場合 O(1) で即 return するため、必要なタイミングでこまめに cancel() しておくと無駄なループを避けられます。 "},{"id":11,"href":"/docs/runtime/game-loop/","title":"GameLoop と状態共有","section":"ランタイム","content":"React 側では engine/hooks/useGameLoop.ts と engine/stores/useGameStore.ts がゲームエンジンを UI に接続します。\nuseGameLoop フック# useGameLoop((dt) =\u0026gt; { game.update(dt); }, isRunning \u0026amp;\u0026amp; game.isRunning); requestAnimationFrame の time から dt（秒）を算出。 isRunning が false のときは RAF を解除し、lastTimeRef をリセット。 ループ中に最新のコールバック参照を使うため useRef で callback を保持。 必要に応じて UI 側から任意の Game インスタンスを渡せます。Expo DevTools のホットリロードでも問題なく再初期化されるよう、useEffect のクリーンアップで cancelAnimationFrame を確実に呼んでいます。\nZustand ストア# engine/stores/useGameStore.ts は Game を 1 つだけ生成し、UI からは start/pause/resume/stop をディスパッチできるようにしています。\nsetRenderPayload(payload) が Game.onRender から届いたデータを tick/elapsed/entities に反映。 toggleRunning() で UI トグルスイッチと同期。 ストアはクライアントサイドのみで使うため、サーバーレンダリングの心配は不要。 GameCanvas 以外の画面（HUD、デバッグパネル、外部ツール）でも同じストアを購読すれば、最新の World スナップショットを共有できます。\n"}]